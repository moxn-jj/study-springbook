# 1. 오브젝트와 의존관계

#### 스프링을 이해하기 위한 과정
- 스프링 -> 오브젝트 -> 오브젝트 설계와 구현

##### 오브젝트 설계와 구현
1. OOP의 기초와 원칙
2. 리팩토링
3. 단위 테스트 

## 1.1 초난감 DAO
기본적으로 사용자 정보 등록/조회하는 기능을 구현하였다. \
다만 현재 난감한 구조이기 때문에 차차 리팩토링해나가 보기로 한다. \
참고로 Database는 연습해보기 위해 처음 사용하는 PostgreSQL로 선택했다.
- 내가 생각하는 현재 구조가 난감한 이유
  1. 데이터베이스 연결 코드가 공통으로 분리되지 않았다.
  2. 패스워드가 그대로 노출된다. (암호화 필요)
  3. 테스트 코드가 Main에 있다.

## 1.2 DAO의 분리
객체를 설계할 때는 미래 변화에 대한 대비를 해야한다. \
객체 지향 설계가 절차 지향보다 좋은 점은 변화에 효과적으로 대처할 수 있다는 점이다. \
좋은 대책이랑 변화의 폭을 최소한으로 줄여주는 것이다. 
#### 관심사의 분리 (Separation of Concerns)
프로그래밍의 기초 개념 중 하나로, 관심이 같은 것끼리는 하나의 객체 안으로, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 기법이다.

UserDao에 Speration of Concerns을 적용해보자. \
UserDao의 관심사는 뭘까? add 메소드만 집중해서 보더라도
1. DB 커넥션
2. 사용자 등록을 위한 SQL
3. 공유 리소스 반환

이러한 관심사를 가지고 있다. 이 중 1번 DB 커넥션은 모든 메소드의 공통된 관심사로 코드 중복이 일어나고 있기 때문에 분리가 필요해 보인다. \
공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 메소드 추출 (Extract Method)를 통해 리팩토링을 진행한다.

이제 커넥션의 내용을 상황에 따라 변경할 수 있도록 해보자. 가장 간단하게 분리할 수 있는 방법이 뭐가 있을까? 바로 `상속`이다.

템플릿 메소드 패턴 (Template Method Pattern)과 팩토리 메소드 패턴 (Factory Method Pattern)을 이용하여 리팩토링 해보자.
1. getConnection을 추상 메소드로 변경하고
2. UserDao를 개별 Dao에서 상속받아 
3. getConnection만 구현하여 사용한다.

UserDao의 getConnection 메소드의 상세구현을 서브 클래스에서 담당하기 때문에 이는 템플릿 메소드 패턴이 적용된 것이고, 동시에 어떤 Connection을 만들지를 서브 클래스에서 담당하고 Connection의 생성을 담당하기 때문에 팩토리 메소드 패턴 또한 적용되었다고 할 수 있다.

## 1.3 DAO의 확장
이와 같이 상속을 통해 공통 코드를 분리하는 것은 간단하지만, 강한 결합이 되어있기 때문에 단점이 많다. 그렇다면 상속 없이 어떻게 해결하면 될까? 생각해보면 User를 다루는 기능과 DB를 연결하는 기능은 관심사가 다르고 변화의 성격이 다르다. 예를 들어 DB의 종류가 변경되는 것은 DB 커넥션의 관심사이지, DAO의 관심사가 아니다. 따라서 이와 같이 관심사가 다른 두 부분을 완전히 다른 클래스로 분리해보자. (이 전에는 메소드로 분리해보았다.)

이 때 만들어진 구조는
1. DB 연결을 담당한는 인터페이스를 생성하고
2. 해당 인터페이스를 상속하는 클래스에서 DB 연결 로직을 구현한다.
3. DAO에서는 생성 시 인터페이스를 받아서 DB 연결에 사용한다.
4. 따라서 관계 설정의 책임이 DAO를 사용할 때로 넘어가게 된다.

UserDAO에서는 어떤 커넥션을 사용하는 지는 알 필요가 없다. 또한 몰라야, 불필요한 의존관계를 끊어낼 수 있다. 따라서 UserDao에서는 단순히 커넥션을 생성하는 인터페이스 타입을 다루고, UserDao를 사용할 때 어떤 커넥션을 사용할 지에 따라서 인스턴스를 생성하고 UserDao로 넘겨준다.

이렇게 코드를 개선하는 과정에서 위에서 소개된 것 외에도 여러 기술이 적용되었다.

##### 개방 폐쇄 원칙 (OCP, Open-Closed Principle)
클래스나 모듈은 확장에 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙
이제 우리는 핵심 기능은 UserDao에 영향을 주지 않고도 DB 커넥션의 종류를 바꿀 수 있다. 따라서 변경에는 닫혀있으면서도 확장에는 열려있다고 할 수 있다.

##### 높은 응집도와 낮은 결합도 (High coherence and low coupling)
응집도가 높다는 것은 하나의 모듈이 하나의 관심사에 집중하고 있다는 것이다.
또한 결합도가 낮다는 것은 다른 모듈과 느슨한 연결이 되어있어 하나의 변경에 대한 파장이 적은 구조를 말한다.

지금까지 개선한 UserDaoTest-UserDao-ConnectionMaker 구조는 디자인 패턴 중 전략 패턴 (Strategy Pattern)에 해당한다고 볼 수 있다. 필요에 따라 변경이 필요한 부분(DB 커넥션)은 인터페이스를 통해 외부로 분리 되어있으며, 이를 구현한 구체적인 클래스를 필요에 따라 바꿔서 사용할 수 있는 구조이기 때문이다.

### 1.4 제어의 역전(IoC)
우리가 지금까지 만든 것들 중 책임을 떠맡은 클래스가 있다. 바로 UserDao의 클래스인 UserDaoTest이다. 어떤 Connect을 만들지 결정하고 생성하는 책임을 가지고 있다. 테스트가 주요한 관심사인 것과는 성격이 다른 책임이다. 따라서 이 책임을 분리해보자.

객체를 생성하는 책임만을 맡는 클래스를 하나 만들어 보겠다. 이른 흔히 `팩토리(Factory)`라고 부른다. 이렇게 팩토리를 생성하므로서 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리할 수 있게 되었다.
```text
애플리케이션의 컴포넌트 역할을 하는 오브젝트?
UserDao이 애플리케이션의 컴포넌트 역할을 한다고 할 수 있으며, 애플리케이션의 특정 기능이나 작업을 수행하는 독립적 작업 단위를 말한다. 비즈니스 로직, 데이터 처리, 외부 시스템과 상호작용 등을 한다. 
```
현재 팩토리 클래스인 DaoFactory를 더 확장 시켜보자. 만약 현재 구조에서 여러개의 Dao를 생성하는 메소드를 추가한다고 생각해보자. 그렇게 되면 ConnectMaker 구현 클래스를 결정하고 생성하는 코드가 중복되게 된다. 이를 해결하기 위해서 Connection에 대한 코드 또한 분리해보자.

이렇게 자신이 사용할 오브젝트를 스스로 선택하고 생성하지 않으며, 어떻게 만들어지고 어디서 사용되는 지 알 수 없는 구조를 제어의 역전이라고 한다. 우리가 만든 UserDao와 DaoFactory를 더 자세히 보자. 본래는 ConnectionMaker의 구현 클래스를 결정하고 생성하는 제어권을 UserDao가 가지고 있었지만 지금은 DaoFactory에 이를 넘겼다. UserDao는 수동적인 존재가 된 것이다. 제어의 역전(IoC)가 일어났다.

스프링은 IoC를 애플리케이션 전반에 걸쳐 적용한 IoC 프레임워크로 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있다.

### 1.5 스프링의 IoC
스프링은 애플리케이션을 개발하기 위한 다양한 기능을 제공하지만, 이 핵심을 담당하는 것은 `빈 팩토리(Bean Factory)` 또는 `애플리케이션 컨텍스트(Application Context)`라고 불리는 것이다. 이는 우리가 만든 DaoFactory가 하는 일을 좀 더 일반화한 것이라고 할 수 있다.

스프링에서 `빈(Bean)`이란 무엇일까? 스프링이 제어권을 가지고 생성하며 관계를 부여하는 오브젝트로 더 정확히 말하자면 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 말한다.

이러한 빈을 만들고 제어하는 것을 `IoC 오브젝트`라고 하며 스프링에서는 `빈 팩토리`가 이를 담당한다. `빈 팩토리`와 `애플리케이션 컨텍스트`는 동의어라고 생각하면 된다. `애플리케이션 컨텍스트`는 일종의 빈 팩토리로, `빈 팩토리`가 빈을 생성하고 관계를 설정하는 IoC 기본 기능 자체에 초점을 맞춘 말이라면 `애플리케이션 컨텍스트`는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 강조된다. 따라서 우리가 스프링에서 IoC에 대해서 말할 때는 당연히 빈팩토리 보다는 애플리케이션 컨텍스트가 더 자주 사용되는 용어이다.

우리가 앞서 만든 DaoFactory는 설정정보를 담고 있는 IoC 엔진이었다. 이를 스프링의 IoC 엔진을 이용한 구성으로 변경해보려 한다. 기존에 담고 있던 설정정보는 유지하여 애플리케이션 컨텍스트가 이를 기반으로 오브젝트를 생성할 수 있도록 해보자.

- `@Configuration`: 빈 팩토리를 위한 오브젝트 설정 클래스임을 나타낸다. 스프링이 해당 어노테이션을 보고 인식한다. 
- `@Bean`: 오브젝트를 만들어 주는 메소드에 붙인다.

해당 어노테이션을 붙여주면서, DaoFactory는 스프링 전용 설정정보를 담고 있는 클래스가 됐다. 
이제 UserDao를 DaoFactory가 아닌 스프링이 관리하는 애플리케이션 컨텍스트에서 가져와 보자. 왜냐하면 기존에 DaoFactory가 객체 생성까지 담당하고 있었던 것에 비해, 객체 생성에 대한 책임은 스프링으로 넘어갔기 때문이다. `ApplicationConext`에서 `getBean()`을 이용해 UserDao를 가져오도록 UserDaoTest 클래스를 수정해보자.
bean의 이름은 기본적으로 메소드이름을 따르게 되어있다.

##### 애플리케이션 컨텍스트의 동작방식
용어 마다 약간의 의미 차이는 있겠지만 스프링에서 애플리케이션 컨텍스트를 아래와 같은 용어로 부를 수 있다. 
```text
애플리케이션 컨텍스트 == IoC 컨테이너 == 스프링 컨테이너 == 빈 팩토리 == 스프링
```
`@Configurate` 어노테이션이 붙은 DaoFactory는 애플리케이션 컨텍스트가 활용하는 IoC 설정정보로 `@Bean`이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다.
사용자가 `getBean()`을 호출하면 빈 목록에서 이를 찾고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 호출하고 생성한 오브젝트를 리턴한다.

DaoFactory를 오브젝트 팩토리로 직접 만들어서 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 아래와 같다.
- 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다: \
  UserDao를 생성하는 팩토리 클래스였던 DaoFactory를 사용자가 직접 알야했던 것에 비해, 애플리케이션 컨텍스트를 이용하면 일관된 방식으로 오브젝트를 가져올 수 있다.
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공한다: \
  단지 오브젝트의 생성과 관계 설정 뿐만아니라, 오브젝트 생성 방식, 시점, 전략, 후처리 등 다양한 기능을 제공한다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다: \
  `getBean()`을 활용하여 빈의 이름 뿐만 아니라 타입, 어노테이션 설정으로도 빈을 찾을 수 있다.

### 1.6 싱글톤 레지스트리와 오브젝트 스코프
DaoFactory를 직접 만들어서 사용하는 것과 @Configuration 어노테이션을 사용하는 것 사이에는 중요한 차이점이 하나 더 있다.
DaoFactory를 통해 UserDao 객체를 2번 가져온 경우와, 애플리케이션 컨텍스트의 getBean()을 통해 UserDao를 2번 가져온 경우 차이를 볼 수 있다. 전자는 두 객체가 동등하나 동일하지 않지만, 후자는 동등하며 동일한 객체가 반환된다. 

즉, 스프링은 여러 번에 걸쳐 빈을 요청해도 항상 동일한 오브젝트를 반환한다. 이와 같이 싱글통으로 오브젝트를 관리하는 애플리케이션 컨텍스트를 싱글톤 레지스트리 (Singleton Registry)라고 한다.

스프링이 싱글톤으로 빈을 만드는 이유는 스프링은 기본적으로 자바 엔터프라이즈 기술을 활용하는 서버 환경을 대상으로 만들어 졌기 때문이다. 한 서버로 초당 수백 번의 요청을 받는 서버는 요청이 올 때마다 오브젝트를 만들게 되면 서버 부하가 일어나기 때문에 싱글톤 패턴으로 오브젝트를 생성한다. 하지만 때때로 이러한 싱글톤 패턴은 문제를 일으키기도 하기 때문에 유의해서 사용해야한다.

##### 싱글톤 구현하는 방법
1. 생성자를 private로 만든다.
2. 싱글톤 오브젝트를 저장할 static field를 정의한다.
3. 스태틱 팩토리 메소드인 getInstance()를 만들고 최초 호출 시에만 오브젝트를 생성하게 하며, 생성된 오브젝트는 스태틱 필드에 저장한다.
4. 한 번 만들어진 이 후에는 getInstance()를 통해 스태틱 필드에 저장된 오브젝트를 넘긴다.
```java
private static UserDao INSTANCE; // 2

private UserDao() {} // 1

public static synchronized UserDao getInstance() { // 3, 4
    if (INSTANCE == null) INSTANCE = new UserDao();
    return INSTANCE;
}
```
##### 싱글톤 패턴의 한계
- private 생성자를 가지기 때문에 상속이 불가하다: \
  생성자를 private로 제한하기 때문에 상속이 불가능하며, 객체지향의 장점인 상속, 다형성을 적용할 수 없다.
  스태틱 필드와 메소드 또한 동일한 문제를 발생 시킨다.
- 테스트가 어렵다: \
  싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 목 오브젝트 등으로 대체하기 어렵고, 초기화 과정에서 생성자를 통해 사용할 오브젝트를 다이나믹하게 주입하는 것도 어렵다.
- 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장할 수 없다: \
  클래스 로더 구성에 따라 싱글톤 클래스도 여러 개가 만들어질 수 있다. 또한 여러 개의 JVM에 분산되어 설치된 경우에도 여러 개의 오브젝트가 생성된다.
- 싱글톤 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다: \
  애플리케이션 어디서나 싱글톤에 쉽게 접근할 수 있으며 이 때문에 자연스럽게 전역 상태로 사용되기 쉽다.
  어디서나 자유롭게 접근, 수정, 공유할 수 있는 전역 상태가 되는 것은 객체지향 프로그래밍에서 권장되지 않는다.

이러한 문제를 해결해주는 것이 바로 스프링의 싱글톤 레지스트리 (Singleton Registry)이다. 싱글톤을 관리하는 컨테이너로 private와 스태틱 메소드가 아닌 평범한 자바 클래스도 싱글톤으로 활용할 수 있게 해준다.
오브젝트 생성에 관한 모든 권한을 IoC 기능을 제공하는 애플리케이션 컨텍스트에 넘겼기 때문에 이와 같은 구조가 가능하다.

그럼에도 불구하고 인스턴스가 싱글톤으로 만들어지기 때문에 주의해야할 점이 있다. 멀티스레드 환경에서 여러 스레드가 동시에 접근할 수 있기 때문에 항상 상태 관리에 주의를 기울여야 한다. 
오브젝트는 상태유지 (stateful) 방식이 아닌 무상태 (statless) 방식으로 만들어져야한다. 상태유지 방식의 경우 인스턴스의 필드 값을 변경하고 유지하지만, 무상태 방식의 경우 상태정보를 내부에 가지고 있지 않다. 예를 들어 ConnectionMaker의 경우 커넥션 자체에 대한 정보를 담고 있기 때문에 초기에 설정하면 사용 중에 변경되지 않는다. 이러한 객체는 인스턴스 필드로 선언해도 되지만 User와 같이 계속해서 변경되는 값은 인스턴스 필드가 아닌 로컬 변수나 파라미터로 주고 받으며 사용해야한다.

스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 가지지만, 경우에 따라 프로토타입 스코프, 요청 스코트, 세션 스코프 등으로 만들어 질 수 있다.
- 프로토타입 스코프, Prototype Scope: 컨테이너에 빈을 요청할 때마다 생성됨
- 요청 스코프, Request Scope: HTTP 요청이 생길 때마다 생성됨
- 세션 스코프, Session Scope: 웹 세션과 유사한 스코프

### 1.7 의존관계 주입(DI)
IoC? DI? 스프링의 의존관계에 대해 말할 때 빼놓지 않고 나오는 용어이다. 이 둘에는 무슨 차이가 있을까?
IoC는 소프트웨어의 일반적인 개념으로 포괄적인 의미로 사용되기 때문에 스프링이 제공하는 IoC 방식을 설명하기에는 부족함이 있다. 이를 위해 만들어진 용어가 DI (Dependency Injection)이다. 때문에 스프링을 말할 때 DI 컨테이너라고 많이 부른다.

의존하고 있다는 것은 무엇일까? A가 B에 의존하고 있다는 것은, B가 변경되면 A에 영향을 끼친다는 뜻이다. 
예를 들어 A가 B의 메소드를 사용하고 있다면 이는 사용에 대한 의존관계에 있는 것이다. 하지만 반대로 B는 A의 변경 사항에 영향을 받지 않는다.

지금까지 만든 구조를 살펴보자. UserDao는 ConnectionMaker를 생성 시에 주입받는다. 따라서 UserDao는 ConnectionMaker에 의존하고 있다. 하지만 ConnectionMaker를 구현한 DConnectionMaker와는 관계가 없기 때문에 그 변경이 UserDao에 영향을 주진 못한다.
이렇게 인터페이스 (여기서 ConnecitonMaker)에 대해서만 의존관계를 만들면 그 구현 클래스 (여기서 DConnectionMaker)와의 관계가 느슨해지면서 영향을 덜 받는 상태가 된다. 이를 결합도가 낮다고도 말한다.
이렇게 UML에 표현할 수 있는 의존관계가 있는 반면 런타임 시에만 만들어지는 의존관계도 있는데 런타임 의존관계는 모델링 시의 의존관계와는 성격이 다르다.

느슨한 의존관계를 갖는 경우는 런타임 전에 어떤 클래스를 사용할 지 알 수 없고 프로그램이 시작되고 나서야 실제 사용대상을 알 수 있다. 이 오브젝트를 `의존 오브젝트 (Dependent Object)`라고 한다.

따라서 의존관계 주입이란 다음 세 가지 조건을 충족하는 작업을 말한다.
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 즉, 인터페이스에만 의존하고 있다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다.

이와 같이 의존관계의 핵심은 설계 시점에는 알지 못하는 두 오브젝트의 관계를 제 3의 존재가 런타임 시에 맺어준다는 것이다.  DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 오브젝트이다. 즉, 앞서 만들었던 DaoFactory나 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 제 3의 존재이다.

##### 의존관계 검색 (Dependency Lookup, DL)
스프링이 제공하는 IoC 방법에는 의존관계 주입만이 있는 것이 아니다. 외부로부터 주입 받는 구조가 아닌 스스로 검색하여 필요로하는 의존 오브젝트를 능동적으로 찾는 `의존관계 검색 (Dependency Lookup)` 방식이 있다.
물론 자신이 어떤 클래스의 오브젝트를 이용할지 결정하는 것은 아니다. (이러면 IoC가 아니다.) 의존관계를 맺을 오브젝트를 결정하고 생성하는 것은 외부 컨테이너에게 맡기지만, 이를 가져올 때 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청한다.

```java
pulic UserDao() {
  DaoFactory daoFactory = new DaoFactory();
  this.connectionMaker = daoFactory.connectionMaker();
}
```
위 코드를 보면 어떤 connectionMaker를 이용할 지에 대한 결정권과 생성은 DaoFactory로 맡기되, 외부로 주입 받지 않고 스스로 IoC 컨테이너인 DaoFactory에게 요청하는 구조로 되어있다.
이와 같은 구조가 의존관계 검색이라고 할 수 있다. 또다른 예를 보자.

아래 코드는 애플리케이션 컨텍스트를 사용해서 의존관계 검색 방식으로 ConnectionMaker를 가져오고 있다.
```java
public UserDao() {
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
  this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
```
의존관계 검색은 의존관계 주입과 유사하지만 방법이 조금 다를 뿐이다. 하지만 의존관계 주입 방식이 조금 더 낫다.
그렇다면 의존관계 겁색은 쓰이지 않을까? 그것은 아니다. 의존관계 검색 방식이 쓰이는 경우가 따로 있다. 바로 애플리케이션 가동 시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. 왜냐하면 스태틱 메소드인 main()에서는 DI를 이용해 오브젝트를 주입받을 수가 없기 때문이다.

또한 두 방법 사이에 중요한 차이점이 하나 있다. 의존관계 검색 방식에서 검색하는 오브젝트는 스프링의 빈일 필요가 없다. UserDao에서 ConnectionMaker에 대한 관계가 설정될 때, 의존관계 주입 방식이라면 두 클래스 모두 스프링의 빈이여야하지만, 의존관계 검색 방식에서는 UserDao는 스프링의 빈일 필요가 없다. 

##### 의존관계 주입의 응용
1. 기능 구현의 교환: \
   예를 들어 운영과 개발의 DB 연결을 다르게 설정하는 경우, DI 방식을 적용해서 만든 경우 컨테이너는 DAO의 생성 시점에 ConnectionMaker 타입을 결정해서 주입하면 된다. 이와 같이 여러 상황에 대응 개발이 필요할 때 여러 부분을 수정할 필요없이 한 곳만 수정하거나 또는 한 부분도 수정하지 않고 대응할 수 있다.
2. 부가기능 추가: \
   예를 들어 DB 연결횟수를 카운팅하는 기능을 추가한다고 생각해보자. 모든 DAO의 코드를 수정할 것인가? 심지어 카운팅 기능은 DAO의 관심 사항도 아니다. 이럴 떄 DI 컨테이너를 이용하면 쉽게 추가할 수 잇다. DAO와 DB 커넥션을 만드는 오브젝트에 연결횟수를 타운팅하는 오브젝트를 하나 추가하는 것이다.
   기존 런타임 오브젝트 의존관계를 보면 UserDao -> DConnectionMaker와 같이 형성되어 있었지만, 카운팅 기능을 추가한 후 UserDao -> CountingConnectionMaker -> DConnectionMaker와 같이 형성된다. 의존 관계를 하나 추가해서 기능을 추가했다. 분석 작업이 끝나면 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하면 런타임 의존관계가 이전으로 돌아가게 된다.  

##### 메소드를 이용한 의존관계 주입
지금까지는 생성자를 사용한 의존관계 주입 방식을 살펴봤지만, 메소드를 이용해서도 의존관계 주입이 가능하다.






















