# 1. 오브젝트와 의존관계

#### 스프링을 이해하기 위한 과정
- 스프링 -> 오브젝트 -> 오브젝트 설계와 구현

##### 오브젝트 설계와 구현
1. OOP의 기초와 원칙
2. 리팩토링
3. 단위 테스트 

## 1.1 초난감 DAO
기본적으로 사용자 정보 등록/조회하는 기능을 구현하였다. \
다만 현재 난감한 구조이기 때문에 차차 리팩토링해나가 보기로 한다. \
참고로 Database는 연습해보기 위해 처음 사용하는 PostgreSQL로 선택했다.
- 내가 생각하는 현재 구조가 난감한 이유
  1. 데이터베이스 연결 코드가 공통으로 분리되지 않았다.
  2. 패스워드가 그대로 노출된다. (암호화 필요)
  3. 테스트 코드가 Main에 있다.

## 1.2 DAO의 분리
객체를 설계할 때는 미래 변화에 대한 대비를 해야한다. \
객체 지향 설계가 절차 지향보다 좋은 점은 변화에 효과적으로 대처할 수 있다는 점이다. \
좋은 대책이랑 변화의 폭을 최소한으로 줄여주는 것이다. 
#### 관심사의 분리 (Separation of Concerns)
프로그래밍의 기초 개념 중 하나로, 관심이 같은 것끼리는 하나의 객체 안으로, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 기법이다.

UserDao에 Speration of Concerns을 적용해보자. \
UserDao의 관심사는 뭘까? add 메소드만 집중해서 보더라도
1. DB 커넥션
2. 사용자 등록을 위한 SQL
3. 공유 리소스 반환

이러한 관심사를 가지고 있다. 이 중 1번 DB 커넥션은 모든 메소드의 공통된 관심사로 코드 중복이 일어나고 있기 때문에 분리가 필요해 보인다. \
공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 메소드 추출 (Extract Method)를 통해 리팩토링을 진행한다.

이제 커넥션의 내용을 상황에 따라 변경할 수 있도록 해보자. 가장 간단하게 분리할 수 있는 방법이 뭐가 있을까? 바로 `상속`이다.

템플릿 메소드 패턴 (Template Method Pattern)과 팩토리 메소드 패턴 (Factory Method Pattern)을 이용하여 리팩토링 해보자.
1. getConnection을 추상 메소드로 변경하고
2. UserDao를 개별 Dao에서 상속받아 
3. getConnection만 구현하여 사용한다.

UserDao의 getConnection 메소드의 상세구현을 서브 클래스에서 담당하기 때문에 이는 템플릿 메소드 패턴이 적용된 것이고, 동시에 어떤 Connection을 만들지를 서브 클래스에서 담당하고 Connection의 생성을 담당하기 때문에 팩토리 메소드 패턴 또한 적용되었다고 할 수 있다.

## 1.3 DAO의 확장
이와 같이 상속을 통해 공통 코드를 분리하는 것은 간단하지만, 강한 결합이 되어있기 때문에 단점이 많다. 그렇다면 상속 없이 어떻게 해결하면 될까? 생각해보면 User를 다루는 기능과 DB를 연결하는 기능은 관심사가 다르고 변화의 성격이 다르다. 예를 들어 DB의 종류가 변경되는 것은 DB 커넥션의 관심사이지, DAO의 관심사가 아니다. 따라서 이와 같이 관심사가 다른 두 부분을 완전히 다른 클래스로 분리해보자. (이 전에는 메소드로 분리해보았다.)

이 때 만들어진 구조는
1. DB 연결을 담당한는 인터페이스를 생성하고
2. 해당 인터페이스를 상속하는 클래스에서 DB 연결 로직을 구현한다.
3. DAO에서는 생성 시 인터페이스를 받아서 DB 연결에 사용한다.
4. 따라서 관계 설정의 책임이 DAO를 사용할 때로 넘어가게 된다.

UserDAO에서는 어떤 커넥션을 사용하는 지는 알 필요가 없다. 또한 몰라야, 불필요한 의존관계를 끊어낼 수 있다. 따라서 UserDao에서는 단순히 커넥션을 생성하는 인터페이스 타입을 다루고, UserDao를 사용할 때 어떤 커넥션을 사용할 지에 따라서 인스턴스를 생성하고 UserDao로 넘겨준다.

이렇게 코드를 개선하는 과정에서 위에서 소개된 것 외에도 여러 기술이 적용되었다.

##### 개방 폐쇄 원칙 (OCP, Open-Closed Principle)
클래스나 모듈은 확장에 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙
이제 우리는 핵심 기능은 UserDao에 영향을 주지 않고도 DB 커넥션의 종류를 바꿀 수 있다. 따라서 변경에는 닫혀있으면서도 확장에는 열려있다고 할 수 있다.

##### 높은 응집도와 낮은 결합도 (High coherence and low coupling)
응집도가 높다는 것은 하나의 모듈이 하나의 관심사에 집중하고 있다는 것이다.
또한 결합도가 낮다는 것은 다른 모듈과 느슨한 연결이 되어있어 하나의 변경에 대한 파장이 적은 구조를 말한다.

지금까지 개선한 UserDaoTest-UserDao-ConnectionMaker 구조는 디자인 패턴 중 전략 패턴 (Strategy Pattern)에 해당한다고 볼 수 있다. 필요에 따라 변경이 필요한 부분(DB 커넥션)은 인터페이스를 통해 외부로 분리 되어있으며, 이를 구현한 구체적인 클래스를 필요에 따라 바꿔서 사용할 수 있는 구조이기 때문이다.

### 1.4 제어의 역전(IoC)
우리가 지금까지 만든 것들 중 책임을 떠맡은 클래스가 있다. 바로 UserDao의 클래스인 UserDaoTest이다. 어떤 Connect을 만들지 결정하고 생성하는 책임을 가지고 있다. 테스트가 주요한 관심사인 것과는 성격이 다른 책임이다. 따라서 이 책임을 분리해보자.

객체를 생성하는 책임만을 맡는 클래스를 하나 만들어 보겠다. 이른 흔히 Factory라고 부른다. 이렇게 팩토리를 생성하므로서 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리할 수 있게 되었다.
```text
애플리케이션의 컴포넌트 역할을 하는 오브젝트?
UserDao이 애플리케이션의 컴포넌트 역할을 한다고 할 수 있으며, 애플리케이션의 특정 기능이나 작업을 수행하는 독립적 작업 단위를 말한다. 비즈니스 로직, 데이터 처리, 외부 시스템과 상호작용 등을 한다. 
```
현재 팩토리 클래스인 DaoFactory를 더 확장 시켜보자. 만약 현재 구조에서 여러개의 Dao를 생성하는 메소드를 추가한다고 생각해보자. 그렇게 되면 ConnectMaker 구현 클래스를 결정하고 생성하는 코드가 중복되게 된다. 이를 해결하기 위해서 Connection에 대한 코드 또한 분리해보자.

이렇게 자신이 사용할 오브젝트를 스스로 선택하고 생성하지 않으며, 어떻게 만들어지고 어디서 사용되는 지 알 수 없는 구조를 제어의 역전이라고 한다. 우리가 만든 UserDao와 DaoFactory를 더 자세히 보자. 본래는 ConnectionMaker의 구현 클래스를 결정하고 생성하는 제어권을 UserDao가 가지고 있었지만 지금은 DaoFactory에 이를 넘겼다. UserDao는 수동적인 존재가 된 것이다. 제어의 역전(IoC)가 일어났다.

스프링은 IoC를 애플리케이션 전반에 걸쳐 적용한 IoC 프레임워크로 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있다.

### 1.5 스프링의 IoC