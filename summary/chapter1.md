# 1. 오브젝트와 의존관계

#### 스프링을 이해하기 위한 과정
- 스프링 -> 오브젝트 -> 오브젝트 설계와 구현

##### 오브젝트 설계와 구현
1. OOP의 기초와 원칙
2. 리팩토링
3. 단위 테스트 

## 1.1 초난감 DAO
기본적으로 사용자 정보 등록/조회하는 기능을 구현하였다. \
다만 현재 난감한 구조이기 때문에 차차 리팩토링해나가 보기로 한다. \
참고로 Database는 연습해보기 위해 처음 사용하는 PostgreSQL로 선택했다.
- 내가 생각하는 현재 구조가 난감한 이유
  1. 데이터베이스 연결 코드가 공통으로 분리되지 않았다.
  2. 패스워드가 그대로 노출된다. (암호화 필요)
  3. 테스트 코드가 Main에 있다.

## 1.2 DAO의 분리
객체를 설계할 때는 미래 변화에 대한 대비를 해야한다. \
객체 지향 설계가 절차 지향보다 좋은 점은 변화에 효과적으로 대처할 수 있다는 점이다. \
좋은 대책이랑 변화의 폭을 최소한으로 줄여주는 것이다. 
#### 관심사의 분리 (Separation of Concerns)
프로그래밍의 기초 개념 중 하나로, 관심이 같은 것끼리는 하나의 객체 안으로, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 기법이다.

UserDao에 Speration of Concerns을 적용해보자. \
UserDao의 관심사는 뭘까? add 메소드만 집중해서 보더라도
1. DB 커넥션
2. 사용자 등록을 위한 SQL
3. 공유 리소스 반환

이러한 관심사를 가지고 있다. 이 중 1번 DB 커넥션은 모든 메소드의 공통된 관심사로 코드 중복이 일어나고 있기 때문에 분리가 필요해 보인다. \
공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 메소드 추출 (Extract Method)를 통해 리팩토링을 진행한다.

이제 커넥션의 내용을 상황에 따라 변경할 수 있도록 해보자. 가장 간단하게 분리할 수 있는 방법이 뭐가 있을까? 바로 `상속`이다.

템플릿 메소드 패턴 (Template Method Pattern)과 팩토리 메소드 패턴 (Factory Method Pattern)을 이용하여 리팩토링 해보자.
1. getConnection을 추상 메소드로 변경하고
2. UserDao를 개별 Dao에서 상속받아 
3. getConnection만 구현하여 사용한다.

UserDao의 getConnection 메소드의 상세구현을 서브 클래스에서 담당하기 때문에 이는 템플릿 메소드 패턴이 적용된 것이고, 동시에 어떤 Connection을 만들지를 서브 클래스에서 담당하고 Connection의 생성을 담당하기 때문에 팩토리 메소드 패턴 또한 적용되었다고 할 수 있다. \
이와 같이 상속을 통해 공통 코드를 분리하는 것은 간단하지만, 강한 결합이 되어있기 때문에 단점이 많다. 그렇다면 상속 없이 어떻게 해결하면 될까? 생각해보면 User를 다루는 기능과 DB를 연결하는 기능은 관심사가 다르고 변화의 성격이 다르다. 예를 들어 DB의 종류가 변경되는 것은 DB 커넥션의 관심사이지, DAO의 관심사가 아니다. 따라서 이와 같이 관심사가 다른 두 부분을 완전히 다른 클래스로 분리해보자. (이 전에는 메소드로 분리해보았다.)


